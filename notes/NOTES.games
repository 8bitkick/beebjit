Files from Stairway To Hell archive unless otherwise noted.


- Arcadians.zip
SHA256: ef37488dcac07cf19c60e4838ae37c2cf00cc09953cd515a32850f09b5adc4b8
Commands to run game:
Start PC: $3F00
IRQ1V @ $0204: $4A9A
EVNTV @ $0220: $FFA6 (default)
Notes:
1) $3F00 jumps to $60D0 which is a relocation loop. $60EE writes over old code,
including $3F00, with new code, using the STA ($70),Y opcode. So -opt
jit:self-mod-all is needed. Eventually, $60FB does JMP $49DA. I think a BEM
file starting at $49DA wouldn't need the jit option.
2) Has a poll wait loop at $4AA7 that needs $0418 and $041B to become different.
This condition occurs when the interrupt handler at $4A9A detects a vsync
interrupt and it does INC $0418 at $4AA1.
3) Has a super interesting condition (bug?) when rendering the blown up ship
animation. Rendering seems to kick off at $5119 by calling $3EC8 a couple of
times to get randomness and storing it as a pointer at $77. Later, at $5144,
this random address is read via AND ($05,X). Depending on the randomness, this
read can and will read arbitrary hardware regsiters and that can and will have
side effects!


- CastleQuest.zip
SHA256: 78ee6b55a6fec679240abd576a83554ba374513d10bd5aff5de4824a114decb1
Start PC: $5460
IRQ1V @ $0204: $DC93 (default)
EVNTV @ $0220: $FFA6 (default)
Notes:
1) Interesting Castle Quest keyboard bug!
CQ uses the MOS keyboard handling routines, but breaks internal MOS state during
it's startup / relocation routines.
Startup is at $5460 and a loop at $54B5 clears the zero page via STA $00,X. This
includes the bytes at $EC and $ED, which contain "which keys are pressed" state.
If these bytes are cleared while a key is down, this leaves the MOS in a state
where it thinks there are no keys down to scan for, and it won't have enabled
the keyboard interrupt, leading to a frozen keyboard. Can be fixed in the
debugger with "sm ec 20".
The bug can be confirmed in other emulators by running the game via:
*CASTLE7
and holding down RETURN indefinitely. When the game starts, the keyboard won't
work. Lovely!


- Camelot.zip
SHA256: d8c2766fb6385ce22efaa5b3d4e2b70863c4a908b24c17709cbc576dfa3c1474
Notes:
1) Crazy loop that runs when an enemy dies (have to be touching as dies).
[ITRP] 2A72: LDX #$01
[ITRP] 2A74: STX $24
[ITRP] 2A76: DEX
[ITRP] 2A77: LDA ($70,X)
[ITRP] 2A79: LDA ($70,X)
[ITRP] 2A7B: DEX
[ITRP] 2A7C: BNE $2A77
That reads from tons of quasi-random pointers which may well have side effects
for those in the hardware register space.
Also does one read where X == 0x8F, leading to a 16-bit pointer being fetched
from $FF and (wrapped) $00, which is very rare.


- Citadel.zip
SHA256: 741b4efd3b5be7092b09c63529e1104b428d0474b4556d8720a4110b31ec3863
IRQ1V @ $0204: $DC93 (default)
EVNTV @ $0220: $2500
Notes:
1) Opcode 0x04, NOP zp undocumented instruction used in loader at $549D.
2) Opcode 0x9C, SHY abx undocumented instruction at $55CB.
3) Breaking at $55E8 is where the main game has finished loading from disk.
4) Need to load the loader first to select key layout for main game to work.
5) Loops at $4110 waiting for 4 vsync ticks, read from $0120. Event handler at
$2500 simply does INC $0120; RTS.
6) Trampoline bounce noise uses periodic white noise with very long period.


- Exile.zip
SHA256: 67aac020f216178d8a89237faa86825611834fbaa79915c1604bd07b60d83268
Start PC: $6075
IRQ1V @ $0204: $12A6
Notes:
1) Routine at $2687 detects the presence of sideways RAM or not. It cycles
through all values (0x0F - 0x00) of ROM select, checking for each whether the
full $8000 - $C000 range can reflect back reads for writes of #$AA and #$55.
2) Sideways RAM detection routine writes to user VIA as well as $FE30 (ROM
select) and $FE32 (ROM select alias). Maybe some old sideways RAM add-on was
attached or controlled via the user VIA's port b?
3) For turbo speed, patch out vsync with NOPs at $1F65, $1F66.
Notes:
4) Uses SED, at $6045, as part of checksumming the saved game file?
5) Lots of self-modifying code.
6) Seems to use zero-page wraparound for zero page X addressing mode at $223D
with ADC $B6,X. And some further instances below.
7) Loader routine at $2CE2 is doing some unusual 16-bit wraps:
[ITRP] 2CE2: LDA $FF63,Y
[ITRP] 2CE5: SBC $FF6C,Y
[ITRP] 2CE8: INY
[ITRP] 2CE9: BNE $2CE2
[...]


- Firetrack.zip
SHA256: 0ca5cdb4bfe8f17eb5bb5328fe48e6b424d36c004101bcc9f7369fb5db64e5c0
Notes:
1) At $221D, uses OSBYTE 129 to read keyboard ($E713).
This calls KEYV, stored at $0228, set to $219E, which calls through to a
keyboard scan at $21A2 by jumping to $EF02.


- Galaforce.zip
SHA256: 923fa8a830bf80d5bc039d4ad328a9d499f4a7e3372e9b6a519f6be19111ce84
Start PC: $4000
IRQ1V @ $0204: $DC93 (default)
EVNTV @ $0220: $0D8F
Notes:
1) Loader code, starting at $4000, is self-modifying. INC $402F, at $4036,
changes the low byte of the operand for LDA $1A00,X, for example.
After relocation, execution continues via JMP $0BEF.
2) Routine starting at $1280 performs LDA $FE44, which is sysvia timer1 counter
low byte. Looks like it's seeding and running an RNG?
3) Game code at $1B04 self-modifies the operand of the LDA #$00 at $1B1E.
4) Game code at $0B5A, first time through, starts writing at high addresses,
the first being $C039?? That's ROM, not writeable.
5) Sprite plot routine is at $0B00 and starts with a bunch of self-modifying
writes.


- Hopper.zip
SHA256: 58075e601f23abaec1d8465da1fe09e8d770e1ab19d55afdd0c0e739ee639563
Initial 6502 PC: $41D0
IRQ1V @ $0204: $DC93 (default)
EVNTV @ $0220: $FFA6 (default)
Notes:
1) Uses SED.
2) Self-modifies a drawing route at $1F8E using aby addressing mode:
STA $2004,Y. Routine starts at $1F7A. 8 bytes of code are written.
3) Self-modified instructions are different opcodes, e.g. starts with
LDA ($72),Y vs. LDA #$30.
4) Doesn't sync to vsync so need to slow it down to play!


- Meteors.zip
SHA256: 176e00afc9a83a1b07b8ec711f822398b8f5e64c2b014dde1940f8a958388e7d
Notes:
1) Loads T1CH, LDA $FE65 at $1601, which is not super common.
2) Seems to be using the user VIA timers, although the game seems to work well
with the user VIA timer not wired up?


- MrEe.zip
SHA256: 388ce49e3efcb492e27572f440106be08e5fbe2ce888d2dcaec7feb31fb9edda
1) Immediately, $4302 writes to ROM?! via STA $801B.
2) Uses SED, ugh, first instance $0DB5. Unclear why.
3) Waits for uservia timer to fire at $0987.


- Pipeline.zip
SHA256: 1a52d9fb8acd6cd130aadd96a179e736845f45176202530df72c8e4f6c78acf2
Notes:
Possible bug?
[2346] 2346: LDA #$0e
[2348] 2348: LDX #$04
[234a] 234a: JMP $fff4
[234d] 234d: LDY #$dd
[234f] 234f: LDA $7dce,Y
[...]
The JMP $FFF4 returns to the original sequence by jumping through an indirect vector at $220, which contains the value $2349. As you can see from the sequence, the correct value might well be $234d.
But if we resume at $2349, we "accidentally"? get the same effect:
[2349] 2349: NOP $4c
[234b] 234b: NOP $ff,X
[234d] 234d: LDY #$dd
[234f] 234f: LDA $7dce,Y


- RocketRaid.zip
SHA256: 535731b6c03aa8a13b9828f657fe247041c1740ee4e1c2d04adbe0ec65a9f585
Start PC: $3400
IRQ1V @ $0204: $DC93 (default)
EVNTV @ $0220: $FFA6 (default)
Notes:
1) Super interesting possible bug? Gets stuck in this loop:
[1c47] 1c47: LDA #$02
[1c49] 1c49: BIT $fe4d
[1c4c] 1c4c: BEQ $1c47
[1c4e] 1c4e: RTS
It gets stuck because my emulator currently has different interrupt timing but
even on a real BBC, this does not appear guaranteed to exit. It's trying to
detect vsync but interrupts are enabled and the standard MOS sysvia interrupt
handler is active. The MOS interrupt handler will take the vsync interrupt and
clear the bit in $FE4D. So this loop, to exit, relies on the vsync interrupt
arriving in the last cycle of the LDA #$02 or the first three cycles of the
BIT.


- Snapper-v1.zip
SHA256: 0829a362d305ee3ec238882780c279d27f26e18e9d4408f830d4e7d9b0e29a68
IRQ1V @ $0204: $DC93 (default)
Notes:
- Interesting wait loop at $10D3, which is simply polling $FE60 waiting for it
to change. This value automagically changes in the hardware as the user VIA
timer 1 rolls over, if the ACR register has bit 0x80 set. This is separate from
the timer interrupt and indeed the IER for the user VIA is 0x00.


- StrykersRun.zip
SHA256: 28fd9fe27a55d5ddecee840c0f9b7a28b22a137f25ae5c91c18aae6a4e2c3c36
Notes:
- Interesting wait loop at $2B2C, waiting for sysvia T2CH to hit a certain
value.
- Some form of screen plotting loop at $0038 (yes, zero page). Looks to be
hosted there in order for speed; uses a self-modifying DEC $3F in a tight loop,
where the DEC influences both an LDA idy and STA abs:
[ITRP] 0038: LDA ($3F),Y
[ITRP] 003A: AND #$55
[ITRP] 003C: EOR #$28
[ITRP] 003E: STA $7363
[ITRP] 0041: LDA $3F
[ITRP] 0043: AND #$07
[ITRP] 0045: BEQ $0050
[ITRP] 0047: DEC $3F
[ITRP] 0049: DEX
[ITRP] 004A: BNE $0038


- Syncron.zip
SHA256: 0bdec178a5b680715b0ac58e74eb3290e1427144f05ca5b47434d66afa782aa5
Start PC: $7400
IRQ1V @ $0204: $045C
EVNTV @ $0220: $D9CD (??)
Notes:
1) Interesting "VIA timer is working??" check at $741F: LDA $FE44; CMP $FE44.
Calls BRK if the compare fails. Breaks an emulator that decrements timers
asynchronously!


- Tarzan-Alligata.zip
SHA256: 31c18df44e7fa743a0cdfd7b20b4dd8fe89106d251eee6904f0076d203188cd8
Start PC: $4332
IRQ1V @ $0204: $DC93 (default)
Notes:
1) Initial relocation routine jumps to $2E11 at $438E.
2) There's test for vsync: BIT $FE4D at $24D9. The followed BEQ at $24DC can be
nop'd out with two bytes of EA, to get a version speed limited only by
emulator speed.


- Wizadore.zip
SHA256: 5811de44e405c1cbd2ec8272e6eb58d12ef384368edd59bab602fa0c3a500274
Notes:
1) Same zero page plotting routing as Stryker's Run above (same author), but at
$006C.
2) Possible bug in vsync wait loop at $1ED1?
[ITRP] 1ED1: BIT $FE4D
[ITRP] 1ED4: BEQ $1ED1
[ITRP] 1ED6: LDA #$82
[ITRP] 1ED8: STA $FE4E
[ITRP] 1EDB: RTS
The loop will exit for non-vsync interrupts, depending on timings. This
includes T1 and keyboard.


- Zalaga.zip
SHA256: 76b0a9c7fe4ff72b778c621bf044d3f3fc7f0bd46e6076de5e87ddc5ec0a44e9
Notes:
- Undocumented instruction NOP $32A5,X at $221A.
- Undocumented instruction SAX $80 at $10B0.
- Undocumented instruction ALR #$AA at $10B2.
- Undocumented instruction SLO $80 at $10B4.

