zip files from Stairway To Hell archive and FSD files from Bill Carr's archive
unless otherwise noted.


- 001 EXILE.FSD
SHA256: 5174e5badcc7ff9703c796249a83d75f8c2fc84133f6156fa1755f84f36ee781
1) !BOOT executes at $1F10 and starts unpacking shenanigans right away.
2) Execution arrives at $1F2C. First OSWORD $7F at $1F70, it's $1B aka. read
sector IDs, it reads one of the protected tracks, the IDs are read into $700.
3) After more unpacking, execution is at $1FA2, then some disc reading, then
at $1FDC there's JMP ($0701), which jumps to $7800.
4) Rewires I/O vectors and bounces back into BASIC to CH."!B" at $7887.
5) BASIC does *LO.EXILE (image?) then *RUN EXILEL.
6) EXILEL executes at $7405. Horrors ensue:
[ITRP] 7409: LDA #$4D
[ITRP] 740B: PHA
[ITRP] 740C: LDY #$00
[ITRP] 740E: PLP
That turns on the decimal flag which is used in an unpacker to rely on ADC
behavior and flags in the presence of "invalid" BCD digits:
[ITRP] 73E7: EOR #$F2
[ITRP] 73E9: ADC $70
[ITRP] 73EB: ADC $73F2
[ITRP] 73EE: STA $70
[ITRP] 73F0: EOR $3000,Y
[ITRP] 73F3: STA $3000,Y
[ITRP] 73F6: EOR $70
[ITRP] 73F8: INY
[ITRP] 73F9: BNE $7416
[ITRP] 73FB: INC $73F2
[ITRP] 73FE: INC $73F5
7) Eventually the unpacker loops overwrites itself at $73E7. EOR #$F2 becomes
BNE $73DB which is taken to continue.


- 008 Hopper 40-80.FSD
SHA256: 3390bacd6d80130cd0a38c533e4ac964226f9a24e910ffc3deeb14a5ad4e53b4
1) Obfuscated loader sequence at $285D, lots of undocumented NOP opcodes,
different from those noted below in the REPTON.FSD notes.
2) Uses SAX abs at $2864 and other places.
3) Uses LAX zpg (first example of LAX found!) at $7AC1.


- 080 REPTON.FSD
SHA256: f16492b1a08e2f06eb933a15baf5cbb5ed92c2fdb02ed142e64a4add115c54cc
1) Uses 8271 command $16 to read a single 128 byte deleted sector.
2) Obfuscated loader sequence at $2BE0, uses tons of undocumented NOP opcode
variants (abx, abs, zpg, zpx) not commonly seen elsewhere to try and
confuse disassemblers?


- AndroidAttack_B.hq.zip
SHA256: e15f6c6cf5db88c275f98cfd4c5863e3e43afd1d82aa5947e28b7ce1f9ade74e
Notes:
1) Has some form of custom tape loader, emits stuff like:
DEBUG (VERY UNUSUAL): 16-bit ADDRESS WRAP at $31E6 to $00C6
2) Uses LAX abs directly after loading!
[ITRP] 1102: LAX $0258
[ITRP] 1105: NOP
[ITRP] 1106: NOP
[ITRP] 1107: NOP $0000,X
[ITRP] 110A: CPX #$02
[ITRP] 110C: BNE $111D



- Arcadians.zip
SHA256: ef37488dcac07cf19c60e4838ae37c2cf00cc09953cd515a32850f09b5adc4b8
Commands to run game:
Start PC: $3F00
IRQ1V @ $0204: $4A9A
EVNTV @ $0220: $FFA6 (default)
Notes:
1) $3F00 jumps to $60D0 which is a relocation loop. $60EE writes over old code,
including $3F00, with new code, using the STA ($70),Y opcode. So -opt
jit:self-mod-all is needed. Eventually, $60FB does JMP $49DA. I think a BEM
file starting at $49DA wouldn't need the jit option.
2) Has a poll wait loop at $4AA7 that needs $0418 and $041B to become different.
This condition occurs when the interrupt handler at $4A9A detects a vsync
interrupt and it does INC $0418 at $4AA1.
3) Has a super interesting condition (bug?) when rendering the blown up ship
animation. Rendering seems to kick off at $5119 by calling $3EC8 a couple of
times to get randomness and storing it as a pointer at $77. Later, at $5144,
this random address is read via AND ($05,X). Depending on the randomness, this
read can and will read arbitrary hardware regsiters and that can and will have
side effects!


- Camelot.zip
SHA256: d8c2766fb6385ce22efaa5b3d4e2b70863c4a908b24c17709cbc576dfa3c1474
Notes:
1) Crazy loop that runs when an enemy dies (have to be touching as dies).
[ITRP] 2A72: LDX #$01
[ITRP] 2A74: STX $24
[ITRP] 2A76: DEX
[ITRP] 2A77: LDA ($70,X)
[ITRP] 2A79: LDA ($70,X)
[ITRP] 2A7B: DEX
[ITRP] 2A7C: BNE $2A77
That reads from tons of quasi-random pointers which may well have side effects
for those in the hardware register space.
Also does one read where X == 0x8F, leading to a 16-bit pointer being fetched
from $FF and (wrapped) $00, which is very rare.
2) QUEST23 executes $2A43, which immediately executes code in the stack page
(loaded from QUEST21), via JSR $015F.
3) Game start screen, "PRESS SPACE TO START", is looping at $0BE8, which passes
keycode $9D to routine $39A5, which just calls OSBYTE 129 (read key with time
limit).
4) After pressing space, $3876 disables the keyboard interrupt by writing
$3D to $FE4E.
5) Disabling the keyboard interrupt isn't sufficient to disable the MOS
interrupt driven keyboard handling, if the interrupt is already disabled. This
state is possible if there's a key down, in which case MOS is polling every
10ms to see if it's been released. MOS will re-enable the interrupt when the
key is detected as released.
6) With the keyboard interrupt back on again, normal MOS keyboard handling
proceeds and the keyboard buffer at $03E0 is filled up with key presses.
Unfortunately, $03E0 is used to store one of the sprite frames for walking
right, which gets corrupted!


- CastleQuest.zip
SHA256: 78ee6b55a6fec679240abd576a83554ba374513d10bd5aff5de4824a114decb1
Start PC: $5460
IRQ1V @ $0204: $DC93 (default)
EVNTV @ $0220: $FFA6 (default)
Notes:
1) Interesting Castle Quest keyboard bug!
CQ uses the MOS keyboard handling routines, but breaks internal MOS state during
it's startup / relocation routines.
Startup is at $5460 and a loop at $54B5 clears the zero page via STA $00,X. This
includes the bytes at $EC and $ED, which contain "which keys are pressed" state.
If these bytes are cleared while a key is down, this leaves the MOS in a state
where it thinks there are no keys down to scan for, and it won't have enabled
the keyboard interrupt, leading to a frozen keyboard. Can be fixed in the
debugger with "sm ec 20".
The bug can be confirmed in other emulators by running the game via:
*CASTLE7
and holding down RETURN indefinitely. When the game starts, the keyboard won't
work. Lovely!


- Citadel.zip
SHA256: 741b4efd3b5be7092b09c63529e1104b428d0474b4556d8720a4110b31ec3863
IRQ1V @ $0204: $DC93 (default)
EVNTV @ $0220: $2500
Notes:
1) Opcode 0x04, NOP zp undocumented instruction used in loader at $549D.
2) Opcode 0x9C, SHY abx undocumented instruction at $55CB.
3) Breaking at $55E8 is where the main game has finished loading from disk.
4) Need to load the loader first to select key layout for main game to work.
5) Loops at $4110 waiting for 4 vsync ticks, read from $0120. Event handler at
$2500 simply does INC $0120; RTS.
6) Trampoline bounce noise uses periodic white noise with very long period.


- Devil's Island
IRQ1V @ $0204: $60E5
1) IRQ1V handles vsync interrupt, starting at $610D.
- Sets ULA to ($C4 | current flash). [20 chars per line]
- Sets color palette.
- Sets horiz displayed to $20.
- Sets horiz position to $2E.
- Sets T1 to fire in 100us or so.
- Sets T2 to fire in 10848us or so.
2) IRQ1V handles T1 interrupt.
- Passed on to MOS for standard handling, presumably keyboard etc.
3) IRQ1V handles T2 interrupt, starting at $617A -> $6183.
- Plenty of timing jitter on entry, particularly due to SEI block at $E465.
- Vertical counter 0x0F, scanline 6.
- Typical horizontal counter jitter range at least 0x12 - 0x3B.
- About half-way down the screen.
- Sets interlace to $31. [display off]
- Sets ULA to $88. [40 chars per line]
- Sets color palette.
- Sets horiz displayed to $00.
- Sets horiz position to $31 (from $2E).
- Race condition here! If horiz counter is e.g. $2D / $2E or thereabouts,
you'll get two hsyncs.
- Sets T2 to fire in 2304us or so.
4) IRQ1V handles T2 interrupt, starting at $617A -> $61CA.
- Sets horiz displayed to $28.
- Sets interlace to $01. [display on]
- Sets T1 to fire in 100us or so.


- Exile.zip
SHA256: 67aac020f216178d8a89237faa86825611834fbaa79915c1604bd07b60d83268
Start PC: $6075
IRQ1V @ $0204: $12A6
Notes:
1) Routine at $2687 detects the presence of sideways RAM or not. It cycles
through all values (0x0F - 0x00) of ROM select, checking for each whether the
full $8000 - $C000 range can reflect back reads for writes of #$AA and #$55.
2) Sideways RAM detection routine writes to user VIA as well as $FE30 (ROM
select) and $FE32 (ROM select alias). Maybe some old sideways RAM add-on was
attached or controlled via the user VIA's port b?
3) For turbo speed, patch out vsync with NOPs at $1F65, $1F66.
Notes:
4) Uses SED, at $6045, as part of checksumming the saved game file?
5) Lots of self-modifying code.
6) Seems to use zero-page wraparound for zero page X addressing mode at $223D
with ADC $B6,X. And some further instances below.
7) Loader routine at $2CE2 is doing some unusual 16-bit wraps:
[ITRP] 2CE2: LDA $FF63,Y
[ITRP] 2CE5: SBC $FF6C,Y
[ITRP] 2CE8: INY
[ITRP] 2CE9: BNE $2CE2
[...]
8) Sampled speech in sideways RAM enhanced version appears to use 1-bit
samples. Frequency of a channel is set to 1 and then 0x90 / 0x9F are written
alternately to the sound chip, which is max / zero volume for that channel.


- Firetrack.zip
SHA256: 0ca5cdb4bfe8f17eb5bb5328fe48e6b424d36c004101bcc9f7369fb5db64e5c0
Notes:
1) At $221D, uses OSBYTE 129 to read keyboard ($E713).
This calls KEYV, stored at $0228, set to $219E, which calls through to a
keyboard scan at $21A2 by jumping to $EF02.


- Galaforce.zip
SHA256: 923fa8a830bf80d5bc039d4ad328a9d499f4a7e3372e9b6a519f6be19111ce84
Start PC: $4000
IRQ1V @ $0204: $DC93 (default)
EVNTV @ $0220: $0D8F
Notes:
1) Loader code, starting at $4000, is self-modifying. INC $402F, at $4036,
changes the low byte of the operand for LDA $1A00,X, for example.
After relocation, execution continues via JMP $0BEF.
2) Routine starting at $1280 performs LDA $FE44, which is sysvia timer1 counter
low byte. Looks like it's seeding and running an RNG?
3) Game code at $1B04 self-modifies the operand of the LDA #$00 at $1B1E.
4) Game code at $0B5A, first time through, starts writing at high addresses,
the first being $C039?? That's ROM, not writeable.
5) Sprite plot routine is at $0B00 and starts with a bunch of self-modifying
writes.


- Hopper.zip
SHA256: 58075e601f23abaec1d8465da1fe09e8d770e1ab19d55afdd0c0e739ee639563
Initial 6502 PC: $41D0
IRQ1V @ $0204: $DC93 (default)
EVNTV @ $0220: $FFA6 (default)
Notes:
1) Uses SED.
2) Self-modifies a drawing route at $1F8E using aby addressing mode:
STA $2004,Y. Routine starts at $1F7A. 8 bytes of code are written.
3) Self-modified instructions are different opcodes, e.g. starts with
LDA ($72),Y vs. LDA #$30.
4) Doesn't sync to vsync so need to slow it down to play!


- Infinity.zip
SHA256: 1e81b458c6e70205277ff6610f4a7cf4fa9263ee96a2f58bc9242562ca37c96a
Notes:
1) Has a loop of write patches at $1EE7:
[1EE7] 1EE7: LDX $0100,Y
[1EE7] 1EEA: DEY
[1EE7] 1EEB: LDA $0100,Y
[1EE7] 1EEE: STA $71
[1EE7] 1EF0: DEY
[1EE7] 1EF1: LDA $0100,Y
[1EE7] 1EF4: STA $70
[1EE7] 1EF6: TXA
[1EE7] 1EF7: STA ($70),Y
[1EE7] 1EF9: DEY
[1EFA] 1EFA: BPL $1EE7
Writes to $FC69, $FC66, $FC63, $FC60... $FC51 as part of its writes, for
unknown reasons. Doesn't do anything on an unexpanded model B.


- LunarJetman.zip
SHA256: 1eeebe6dff5dddfe20e765e1bc3c62e2af5818aeead7d644fd14db74e110e3f4
Notes:
1) Strange read of $FEA9:
[ITRP] 332B: JSR $49B5
[ITRP] 332E: AND #$04
[ITRP] 3330: SEC
[ITRP] 3331: SBC #$02
[ITRP] 3333: BIT $FEA9
[ITRP] 3336: STA $01A0,X
[ITRP] 3339: RTS


- Meteors.zip
SHA256: 176e00afc9a83a1b07b8ec711f822398b8f5e64c2b014dde1940f8a958388e7d
Notes:
1) Loads T1CH, LDA $FE65 at $1601, which is not super common.
2) Seems to be using the user VIA timers, although the game seems to work well
with the user VIA timer not wired up?


- MrEe.zip
SHA256: 388ce49e3efcb492e27572f440106be08e5fbe2ce888d2dcaec7feb31fb9edda
1) Immediately, $4302 writes to ROM?! via STA $801B.
2) Uses SED, ugh, first instance $0DB5. Unclear why.
3) Waits for uservia timer to fire at $0987.


- Pipeline.zip
SHA256: 1a52d9fb8acd6cd130aadd96a179e736845f45176202530df72c8e4f6c78acf2
Notes:
Possible bug?
[2346] 2346: LDA #$0e
[2348] 2348: LDX #$04
[234a] 234a: JMP $fff4
[234d] 234d: LDY #$dd
[234f] 234f: LDA $7dce,Y
[...]
The JMP $FFF4 returns to the original sequence by jumping through an indirect vector at $220, which contains the value $2349. As you can see from the sequence, the correct value might well be $234d.
But if we resume at $2349, we "accidentally"? get the same effect:
[2349] 2349: NOP $4c
[234b] 234b: NOP $ff,X
[234d] 234d: LDY #$dd
[234f] 234f: LDA $7dce,Y


- PharaohsCurse.zip
SHA256: 890d62e4fe4fc8137a8c73280425a1bfcb7e93ab8891d6b0dae6cb6469202572
Notes:
1) At game start, fakes a light pen pulse:
[ITRP] 1048: LDA #$C5
[ITRP] 104A: STA $FE4C
[ITRP] 104D: LDA #$E5
[ITRP] 104F: STA $FE4C
[ITRP] 1052: LDA #$10
[ITRP] 1054: STA $FE00
[ITRP] 1057: LDA $FE01


- Repton2.zip
SHA256: 2e72f2d0ca1f8fe043be9f7b7e78055d16340ea0ff32682df73f17ea072c200b
Notes:
1) Uses single(?) instanceof ANC imm undocumented opcode, called once per
title screen:
[ITRP] 220C: JSR $10F5      [A=00 X=00 Y=01 S=EF F= Z   1  ]
[ITRP] 10F5: ANC #$0A       [A=00 X=00 Y=01 S=ED F= Z   1  ]
2) Probable bug? Actives sound write enable (low) while setting up screen
addresses, see store at $4157.
[ITRP] 4154: SEI
[ITRP] 4155: LDA #$00
[ITRP] 4157: STA $FE40
[ITRP] 415A: LDA #$0C
[ITRP] 415C: STA $FE40
[ITRP] 415F: LDA #$05
[ITRP] 4161: STA $FE40
[ITRP] 4164: CLI
Sound write enable is left low indefinitely, will likely cause intermittent
sound problems if keyboard interrupt or scan occurs in this window.
Later, sound write enable is pulled low again without an intervening pull high:
[ITRP] 2CAA: LDX #$FF
[ITRP] 2CAC: STX $FE43
[ITRP] 2CAF: STA $FE4F
[ITRP] 2CB2: INX
[ITRP] 2CB3: STX $FE40
This is actually ok, the sound chip doesn't need to see a high -> low
transition, but is likely not what was intended.


- RocketRaid.zip
SHA256: 535731b6c03aa8a13b9828f657fe247041c1740ee4e1c2d04adbe0ec65a9f585
Start PC: $3400
IRQ1V @ $0204: $DC93 (default)
EVNTV @ $0220: $FFA6 (default)
Notes:
1) Super interesting possible bug? Gets stuck in this loop:
[1c47] 1c47: LDA #$02
[1c49] 1c49: BIT $fe4d
[1c4c] 1c4c: BEQ $1c47
[1c4e] 1c4e: RTS
It gets stuck because my emulator currently has different interrupt timing but
even on a real BBC, this does not appear guaranteed to exit. It's trying to
detect vsync but interrupts are enabled and the standard MOS sysvia interrupt
handler is active. The MOS interrupt handler will take the vsync interrupt and
clear the bit in $FE4D. So this loop, to exit, relies on the vsync interrupt
arriving in the last cycle of the LDA #$02 or the first three cycles of the
BIT.


- Snapper-v1.zip
SHA256: 0829a362d305ee3ec238882780c279d27f26e18e9d4408f830d4e7d9b0e29a68
IRQ1V @ $0204: $DC93 (default)
Notes:
- Interesting wait loop at $10D3, which is simply polling $FE60 waiting for it
to change. This value automagically changes in the hardware as the user VIA
timer 1 rolls over, if the ACR register has bit 0x80 set. This is separate from
the timer interrupt and indeed the IER for the user VIA is 0x00.


- SpyHunter.zip
SHA256: 3dcbb5bb7cebd8211a935dee20a1698f78baf99bc5ab643cf23337a87ea74d91
Notes:
1) Sample playback code.
After *LOAD HUNTER1, playback code at $3A00.
Sets tone channel 1 and 3 frequency to 1. (Also channel 2 but its not used.)
Uses user VIA counter to time 65us events via IFR polling.
Writes the same volume to channel 1 and 3 for each 4-bit sample at $3A67.


- StrykersRun.zip
SHA256: 28fd9fe27a55d5ddecee840c0f9b7a28b22a137f25ae5c91c18aae6a4e2c3c36
Notes:
- Interesting wait loop at $2B2C, waiting for sysvia T2CH to hit a certain
value.
- Some form of screen plotting loop at $0038 (yes, zero page). Looks to be
hosted there in order for speed; uses a self-modifying DEC $3F in a tight loop,
where the DEC influences both an LDA idy and STA abs:
[ITRP] 0038: LDA ($3F),Y
[ITRP] 003A: AND #$55
[ITRP] 003C: EOR #$28
[ITRP] 003E: STA $7363
[ITRP] 0041: LDA $3F
[ITRP] 0043: AND #$07
[ITRP] 0045: BEQ $0050
[ITRP] 0047: DEC $3F
[ITRP] 0049: DEX
[ITRP] 004A: BNE $0038


- Syncron.zip
SHA256: 0bdec178a5b680715b0ac58e74eb3290e1427144f05ca5b47434d66afa782aa5
Start PC: $7400
IRQ1V @ $0204: $045C
EVNTV @ $0220: $D9CD (??)
Notes:
1) Interesting "VIA timer is working??" check at $741F: LDA $FE44; CMP $FE44.
Calls BRK if the compare fails. Breaks an emulator that decrements timers
asynchronously!
2) Unclear reason for read of $FE18, during some form of initialization:
[ITRP] 7493: LDA #$00
[ITRP] 7495: STA $FE4B
[ITRP] 7498: STA $FE08
[ITRP] 749B: BIT $FE18
[ITRP] 749E: TAX
[ITRP] 749F: STA $00,X
[ITRP] 74A1: STA $0100,X
[ITRP] 74A4: INX
[ITRP] 74A5: BNE $749F
[ITRP] 74A7: JSR $0AD4


- Tarzan-Alligata.zip
SHA256: 31c18df44e7fa743a0cdfd7b20b4dd8fe89106d251eee6904f0076d203188cd8
Start PC: $4332
IRQ1V @ $0204: $DC93 (default)
Notes:
1) Initial relocation routine jumps to $2E11 at $438E.
2) There's test for vsync: BIT $FE4D at $24D9. The followed BEQ at $24DC can be
nop'd out with two bytes of EA, to get a version speed limited only by
emulator speed.


- Uridium.zip
SHA256: 58ffc27c528d93432211ab6beef630a44fdd071c9d312033ffe6829da4ec7097
Start PC: $24D3 (post keyboard selection)
Notes:
1) Bug setting EVENTV?
It does this with interrupts on:
[ITRP] 2532: LDA #$00
[ITRP] 2534: STA $0220
[ITRP] 2537: LDA #$04
[ITRP] 2539: STA $0221
2) Calls $FFE0 at $2543, music plays, bounces out on keypress, jumps to $2900,
calls *RUN Uridium, executes at $6F00.
3) $6F00 relocates and later jumps to $4800.
4) Serious bug in $6F00 relocation routine. It is run with IRQs _enabled_, and
copies page $1100 to $0200. Furthermore, IRQV @$0204 is written with $0200.
There are a few problems here but mainly, IRQV can be overwritten before the
IRQ routine at $0200 is fully copied. Then, if and when an interrupt comes in
during this unforunate race window, it all goes south.
5) At $487B, writes $0F to $FE42 (DDRB) -- carries risk with BBC Master?


- Wizadore.zip
SHA256: 5811de44e405c1cbd2ec8272e6eb58d12ef384368edd59bab602fa0c3a500274
Notes:
1) Same zero page plotting routing as Stryker's Run above (same author), but at
$006C.
2) Possible bug in vsync wait loop at $1ED1?
[ITRP] 1ED1: BIT $FE4D
[ITRP] 1ED4: BEQ $1ED1
[ITRP] 1ED6: LDA #$82
[ITRP] 1ED8: STA $FE4E
[ITRP] 1EDB: RTS
The loop will exit for non-vsync interrupts, depending on timings. This
includes T1 and keyboard.


- Zalaga.zip
SHA256: 76b0a9c7fe4ff72b778c621bf044d3f3fc7f0bd46e6076de5e87ddc5ec0a44e9
Notes:
- Undocumented instruction NOP $32A5,X at $221A.
- Undocumented instruction SAX $80 at $10B0.
- Undocumented instruction ALR #$AA at $10B2.
- Undocumented instruction SLO $80 at $10B4.

